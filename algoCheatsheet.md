# üß† –ê–ª–≥–æ—Ä–∏—Ç–º–∏—á–µ—Å–∫–∞—è —à–ø–∞—Ä–≥–∞–ª–∫–∞: –ø–∞–º—è—Ç–∫–∞ –¥–ª—è —É–≤–µ—Ä–µ–Ω–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è –∑–∞–¥–∞—á

## ‚ú® 1. –ü—Ä–µ–¥–∏—Å–ª–æ–≤–∏–µ

> –ò–¥–µ–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ ‚Äî –Ω–µ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è —Ç–æ—á–∫–∞, –∞ –∫–æ–Ω–µ—á–Ω–∞—è —Ü–µ–ª—å. –ù–∞—á–Ω–∏ –ø—Ä–æ—Å—Ç–æ. –†–µ—à–∏ –≤ –ª–æ–±. –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π –ø–æ—Ç–æ–º.

–¢—ã –Ω–µ –æ–±—è–∑–∞–Ω —Å—Ä–∞–∑—É –∑–Ω–∞—Ç—å O(1)-–≤–∞—Ä–∏–∞–Ω—Ç –∏–ª–∏ –ø–∏—Å–∞—Ç—å —Å –¥–≤—É—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π. –ì–ª–∞–≤–Ω–æ–µ ‚Äî **–Ω–µ –∑–∞—Å—Ç—Ä–µ–≤–∞—Ç—å**. –≠—Ç–∞ —à–ø–∞—Ä–≥–∞–ª–∫–∞ ‚Äî –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ, —Å —á–µ–≥–æ –Ω–∞—á–∞—Ç—å –∏ –∫—É–¥–∞ –∫–æ–ø–∞—Ç—å.

---

## üì¶ 2. –ß–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è –∫–µ–π—Å—ã –∏ —á—Ç–æ —Å –Ω–∏–º–∏ –¥–µ–ª–∞—Ç—å

### üîç 2.1 –ü–æ–∏—Å–∫

#### –î–≤–æ–∏—á–Ω—ã–π –ø–æ–∏—Å–∫ (O(log n))

–ü—Ä–∏–º–µ–Ω–∏–º, –µ—Å–ª–∏:

- –º–∞—Å—Å–∏–≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω
- –Ω—É–∂–Ω–æ –Ω–∞–π—Ç–∏ –≥—Ä–∞–Ω–∏—Ü—É, –º–∞–∫—Å–∏–º—É–º, —É—Å–ª–æ–≤–∏–µ

**–°–∫–µ–ª–µ—Ç:**

```go
left, right := 0, len(nums)-1
for left < right {
    mid := (left + right) / 2
    if —É—Å–ª–æ–≤–∏–µ {
        right = mid
    } else {
        left = mid + 1
    }
}
return left
```

---

### üìÉ 2.2 Sliding Window

#### üîπ –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:
Sliding Window ‚Äî —ç—Ç–æ –º–µ—Ç–æ–¥ –¥–≤—É—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π `left` –∏ `right`, –∫–æ—Ç–æ—Ä—ã–µ –¥–≤–∏–∂—É—Ç—Å—è –ø–æ –º–∞—Å—Å–∏–≤—É, –æ–ø—Ä–µ–¥–µ–ª—è—è "–æ–∫–Ω–æ" –∏–∑ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

---

#### üåê –¢–∏–ø–æ–≤—ã–µ —à–∞–±–ª–æ–Ω—ã:

#### 1. –°—É–º–º–∞/–¥–ª–∏–Ω–∞ –ø–æ–¥–º–∞—Å—Å–∏–≤–∞:
```go
left := 0
sum := 0
for right := 0; right < len(nums); right++ {
    sum += nums[right]
    for sum > target {
        sum -= nums[left]
        left++
    }
    // update max/min length/etc
}
```

#### 2. –ú–∞–∫—Å/–º–∏–Ω –æ–∫–Ω–æ —Å –Ω–µ –±–æ–ª–µ–µ K –æ—à–∏–±–æ–∫:
```go
left := 0
count := 0
for right := 0; right < len(nums); right++ {
    if nums[right] == 0 {
        count++
    }
    for count > 1 {
        if nums[left] == 0 {
            count--
        }
        left++
    }
    // update max window length: right - left
}
```

#### 3. –°–∏–º–≤–æ–ª—ã/—Å—á–µ—Ç—á–∏–∫–∏ –≤ —Å—Ç—Ä–æ–∫–µ (map/rune)
```go
charCount := map[byte]int{}
left := 0
for right := 0; right < len(s); right++ {
    charCount[s[right]]++
    for invalid(charCount) {
        charCount[s[left]]--
        left++
    }
    // update result
}
```

---

#### ‚úÖ –ö–ª—é—á–µ–≤–æ–µ:
- `right` –≤—Å–µ–≥–¥–∞ –∏–¥—ë—Ç –≤–ø–µ—Ä—ë–¥
- `left` —Å–¥–≤–∏–≥–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –Ω–∞—Ä—É—à–µ–Ω–æ —É—Å–ª–æ–≤–∏–µ
- –û–∫–Ω–æ: `[left, right]`
- –ß–∞—Å—Ç–æ –Ω—É–∂–Ω–æ: `right - left + 1` (–∏–ª–∏ `right - left`, –µ—Å–ª–∏ –∏—Å–∫–ª—é—á–∞–µ—Ç —á—Ç–æ-—Ç–æ)

---

### üå≤ 2.3 –î–µ—Ä–µ–≤—å—è, –≥—Ä–∞—Ñ—ã: DFS –∏ BFS

#### DFS (–ø–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É, —Å—Ç–µ–∫ –∏–ª–∏ —Ä–µ–∫—É—Ä—Å–∏—è)

–•–æ—Ä–æ—à–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –æ–±—Ö–æ–¥–∞ –¥–µ—Ä–µ–≤–∞
- –≥—Ä–∞—Ñ–æ–≤ (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ)
- –ø–æ–∏—Å–∫–∞ –ø—É—Ç–µ–π, —Å–≤—è–∑–Ω–æ—Å—Ç–∏

**–ü—Ä–∏–º–µ—Ä (—Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π DFS –Ω–∞ –¥–µ—Ä–µ–≤–µ):**

```go
func dfs(node *TreeNode) {
    if node == nil {
        return
    }
    dfs(node.Left)
    dfs(node.Right)
}
```

**DFS –ø–æ –≥—Ä–∞—Ñ—É —Å visited:**

```go
func dfs(v string, visited map[string]bool) {
    visited[v] = true
    for _, nei := range graph[v] {
        if !visited[nei] {
            dfs(nei, visited)
        }
    }
}
```

---

#### BFS (–ø–æ–∏—Å–∫ –≤ —à–∏—Ä–∏–Ω—É, –æ—á–µ—Ä–µ–¥—å)

–•–æ—Ä–æ—à–æ –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –ø–æ–∏—Å–∫–∞ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏ (–≤ –≥—Ä–∞—Ñ–µ)
- –∑–∞–¥–∞—á "–ø–æ —É—Ä–æ–≤–Ω—è–º"

**–ü—Ä–∏–º–µ—Ä:**

```go
queue := []Node{start}
visited := map[Node]bool{start: true}

for len(queue) > 0 {
    size := len(queue)
    for i := 0; i < size; i++ {
        node := queue[0]
        queue = queue[1:]
        for _, nei := range graph[node] {
            if !visited[nei] {
                visited[nei] = true
                queue = append(queue, nei)
            }
        }
    }
}
```

---

### üß∫ 2.4 Set / Map –≤ Go

```go
set := map[int]struct{}{}
set[val] = struct{}{}
if _, ok := set[val]; ok { ... }
delete(set, val)
```

- `map[int]struct{}` ‚Äî —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–µ–µ, —á–µ–º `map[int]bool`
- –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–∏—Å–∫–∞, —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏, —Å—Ä–∞–≤–Ω–µ–Ω–∏—è

---

### 2.5 üîπ MinHeap (–ú–∏–Ω–∏-–∫—É—á–∞)

#### üìå –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:

- –ù—É–∂–Ω–æ **–æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å k –Ω–∞–∏–±–æ–ª—å—à–∏—Ö / –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤**
- –ß–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∑–∞–¥–∞—á–∞—Ö:
  - `Kth Largest/Smallest Element`
  - `Top K frequent`
  - `Merge K sorted lists`
  - –ü–æ—Ç–æ–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ (streaming) ‚Äî –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å Top K –Ω–∞ –ª–µ—Ç—É

#### ‚úÖ –¢–∏–ø–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:

```go
import "container/heap"

type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] } // min-heap
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *MinHeap) Push(x any)        { *h = append(*h, x.(int)) }
func (h *MinHeap) Pop() any {
    old := *h
    x := old[len(old)-1]
    *h = old[:len(old)-1]
    return x
}
```

#### üõ† –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:

```go
h := &MinHeap{}
heap.Init(h)

heap.Push(h, 3)
heap.Push(h, 1)
heap.Push(h, 2)

min := heap.Pop(h).(int)  // ‚Üí 1
```

#### üìè –°–ª–æ–∂–Ω–æ—Å—Ç—å:
- `heap.Push`, `heap.Pop` ‚Äî O(log n)
- `heap.Init` ‚Äî O(n)

---

### 2.6 üîπ Quickselect

#### üìå –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:

- –ù—É–∂–Ω–æ –Ω–∞–π—Ç–∏ **k-–π –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ (–∏–ª–∏ –ø–æ –ø–æ—Ä—è–¥–∫—É) —ç–ª–µ–º–µ–Ω—Ç**
- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–µ ‚Äî **–≤ —Å—Ä–µ–¥–Ω–µ–º O(n)**
- –ó–∞–¥–∞—á–∏:
  - `Kth Largest Element`
  - `Median of unsorted array`
  - `Top K frequent (–≤–∞—Ä–∏–∞–Ω—Ç—ã)`

#### ‚úÖ –°–∫–µ–ª–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:

```go
func quickSelect(nums []int, left, right, k int) int {
    if left == right {
        return nums[left]
    }

    pivotIndex := partition(nums, left, right)

    if pivotIndex == k {
        return nums[pivotIndex]
    } else if pivotIndex < k {
        return quickSelect(nums, pivotIndex+1, right, k)
    } else {
        return quickSelect(nums, left, pivotIndex-1, k)
    }
}

func partition(nums []int, left, right int) int {
    pivot := nums[right]
    i := left

    for j := left; j < right; j++ {
        if nums[j] < pivot {
            nums[i], nums[j] = nums[j], nums[i]
            i++
        }
    }

    nums[i], nums[right] = nums[right], nums[i]
    return i
}
```

#### üîç –ü—Ä–∏–º–µ—Ä –≤—ã–∑–æ–≤–∞:

```go
// –ß—Ç–æ–±—ã –Ω–∞–π—Ç–∏ k-–π –ø–æ –≤–µ–ª–∏—á–∏–Ω–µ (–æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ —É–±—ã–≤–∞–Ω–∏—é):
index := len(nums) - k
res := quickSelect(nums, 0, len(nums)-1, index)
```

#### üìè –°–ª–æ–∂–Ω–æ—Å—Ç—å:

- **–°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è:** O(n)
- **–•—É–¥—à–µ–µ –≤—Ä–µ–º—è:** O(n¬≤), –µ—Å–ª–∏ –ø–ª–æ—Ö–æ –≤—ã–±—Ä–∞—Ç—å –ø–∏–≤–æ—Ç
- **–ü–∞–º—è—Ç—å:** O(1), –µ—Å–ª–∏ in-place

---

## üîÅ –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤ –ø–æ –æ–±—Ö–æ–¥—É (Z-–æ–±—Ö–æ–¥)

### üìå –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:
- –ï—Å—Ç—å –¥–≤–∞ –º–∞—Å—Å–∏–≤–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç `m1`, `m2`
- –ö–∞–∂–¥–∞—è —Ç–æ—á–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∞ —Å –¥–≤—É–º—è —Å–æ—Å–µ–¥—è–º–∏
- –í–µ—Ä—à–∏–Ω—ã –∑–∞–¥–∞–Ω—ã –≤ –ø–æ—Ä—è–¥–∫–µ –æ–±—Ö–æ–¥–∞ (–≤ –ª—é–±—É—é —Å—Ç–æ—Ä–æ–Ω—É)
- –ù—É–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –æ–ø–∏—Å—ã–≤–∞—é—Ç –ª–∏ –æ–Ω–∏ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –ø–æ–ª–∏–≥–æ–Ω

---

### ‚úÖ –ü–æ–¥—Ö–æ–¥: "–Ø–∫–æ—Ä—å –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ"

1. –í—ã–±—Ä–∞—Ç—å —è–∫–æ—Ä–Ω—É—é —Ç–æ—á–∫—É `m1[0]`
2. –ù–∞–π—Ç–∏ —Ç–∞–∫—É—é –∂–µ —Ç–æ—á–∫—É –≤ `m2`
3. –°—Ä–∞–≤–Ω–∏—Ç—å —Å–ª–µ–¥—É—é—â—É—é —Ç–æ—á–∫—É `m1[1]` —Å —Å–æ—Å–µ–¥—è–º–∏ –≤ `m2`, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ö–æ–¥–∞
4. –û–±—Ö–æ–¥–∏—Ç—å `m2` —Å –Ω–∞–π–¥–µ–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º
5. –ù–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å —Ç–µ–∫—É—â–∏–µ —Ç–æ—á–∫–∏

---

### üîß –†–µ–∞–ª–∏–∑–∞—Ü–∏—è (Go):

```go
func isSamePolygon(m1, m2 [][]int) bool {
    n := len(m1)
    if len(m2) != n {
        return false
    }

    anchor := m1[0]
    start := -1
    for i := 0; i < n; i++ {
        if m2[i][0] == anchor[0] && m2[i][1] == anchor[1] {
            start = i
            break
        }
    }
    if start == -1 {
        return false
    }

    next1 := m1[1]
    nextCW := m2[(start+1)%n]
    dir := 1
    if next1[0] != nextCW[0] || next1[1] != nextCW[1] {
        dir = -1
    }

    for i := 0; i < n; i++ {
        j := (start + dir*i + n) % n
        if m1[i][0] != m2[j][0] || m1[i][1] != m2[j][1] {
            return false
        }
    }

    return true
}
```

---

## üß† –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤ —Å 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –∏–ª–∏ —Å–ª–æ–∂–Ω—ã–º–∏ —Ç–æ—á–∫–∞–º–∏

### üìå –û–±—â–∞—è –∏–¥–µ—è –æ—Å—Ç–∞—ë—Ç—Å—è –ø—Ä–µ–∂–Ω–µ–π:
- –°—Ä–∞–≤–Ω–µ–Ω–∏–µ **–ø–æ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ –æ–±—Ö–æ–¥–∞**
- –£—á–∏—Ç—ã–≤–∞–µ–º **–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ö–æ–¥–∞**
- –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º **–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–µ–∫** ‚Äî –≤ 2D –∏–ª–∏ 3D

---

### üîÅ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è 3D (–∏–ª–∏ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã):

```go
type Point3D struct {
	X, Y, Z int
}

func isSamePolygon3D(m1, m2 []Point3D) bool {
	n := len(m1)
	if len(m2) != n {
		return false
	}

	// –ù–∞–π–¥—ë–º "anchor"
	start := -1
	for i := 0; i < n; i++ {
		if equalPoint3D(m1[0], m2[i]) {
			start = i
			break
		}
	}
	if start == -1 {
		return false
	}

	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
	next1 := m1[1]
	nextCW := m2[(start+1)%n]
	dir := 1
	if !equalPoint3D(next1, nextCW) {
		dir = -1
	}

	// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω
	for i := 0; i < n; i++ {
		j := (start + dir*i + n) % n
		if !equalPoint3D(m1[i], m2[j]) {
			return false
		}
	}

	return true
}

func equalPoint3D(a, b Point3D) bool {
	return a.X == b.X && a.Y == b.Y && a.Z == b.Z
}
```

---

### üß© –ê –µ—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–µ —Ç–æ–ª—å–∫–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã?

–¢–æ–≥–¥–∞ –ø—Ä–æ—Å—Ç–æ –∞–¥–∞–ø—Ç–∏—Ä—É–µ—à—å `equalPoint3D` ‚Üí `equalVertex(a, b)`  
–≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –Ω—É–∂–Ω–æ —Å—Ä–∞–≤–Ω–∏–≤–∞—Ç—å (—Ü–≤–µ—Ç, –∏–º—è, id –∏ —Ç.–¥.)

```go
type Vertex struct {
	ID    string
	Coord Point3D
	Color string
	Meta  map[string]string
}

func equalVertex(a, b Vertex) bool {
	return a.ID == b.ID && a.Color == b.Color &&
		a.Coord == b.Coord // –º–æ–∂–Ω–æ –∏ –≤—Ä—É—á–Ω—É—é —Å—Ä–∞–≤–Ω–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
}
```

---

## üìè –°–ª–æ–∂–Ω–æ—Å—Ç—å:

- –í—Ä–µ–º—è: O(n)
- –ü–∞–º—è—Ç—å: O(1)
- –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ –¥–ª—è –ª—é–±—ã—Ö —Ç–∏–ø–æ–≤

---

### üß† –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
- –í—Ä–µ–º—è: **O(n)**
- –ü–∞–º—è—Ç—å: **O(1)** (–±–µ–∑ –¥–æ–ø. —Å—Ç—Ä—É–∫—Ç—É—Ä)
- –£—á–∏—Ç—ã–≤–∞–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ö–æ–¥–∞
- –ù–µ —Ç—Ä–µ–±—É–µ—Ç —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏, –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–ª–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π

---

### ‚öîÔ∏è MinHeap vs Quickselect ‚Äî –∫–æ–≥–¥–∞ —á—Ç–æ:

| –°—Ü–µ–Ω–∞—Ä–∏–π                            | –õ—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å |
|------------------------------------|---------------------|
| –ù–∞–π—Ç–∏ **k-–π —ç–ª–µ–º–µ–Ω—Ç**              | Quickselect         |
| **–û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å k –ª—É—á—à–∏—Ö** –æ–Ω–ª–∞–π–Ω    | MinHeap (—Ä–∞–∑–º–µ—Ä k)  |
| –û–±–Ω–æ–≤–ª—è–µ–º—ã–µ –ø–æ—Ç–æ–∫–∏ / —Å—Ç—Ä–∏–º         | MinHeap             |
| –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –ø–æ k         | –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –æ–¥–∏–Ω —Ä–∞–∑ |

---

### üí° 2.5 –ß–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã

- **Stack** ‚Äî –µ—Å–ª–∏ –Ω–∞–¥–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å "—Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ + —É–¥–∞–ª—è—Ç—å/–æ—Ç–º–µ–Ω—è—Ç—å" (`remove stars`, `valid parentheses`, `monotonic stack`)
- **Prefix Sum / Diff Array** ‚Äî –µ—Å–ª–∏ –Ω—É–∂–Ω—ã –±—ã—Å—Ç—Ä—ã–µ –¥–∏–∞–ø–∞–∑–æ–Ω–Ω—ã–µ —Å—É–º–º—ã
- **Dynamic Programming (DP)** ‚Äî –µ—Å–ª–∏ –ø–æ–¥–∑–∞–¥–∞—á–∏ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—é—Ç—Å—è
- **Backtracking** ‚Äî –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã (–ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏, sudoku)

---

## üîö 3. –ü–æ—Å–ª–µ—Å–ª–æ–≤–∏–µ

–¢—ã –Ω–µ –æ–±—è–∑–∞–Ω —Å—Ä–∞–∑—É –ø–æ–º–Ω–∏—Ç—å –≤—Å—ë. –≠—Ç–∞ –ø–∞–º—è—Ç–∫–∞ ‚Äî –∫–∞–∫ —Ä—É—á–Ω–æ–π —Ç–æ—Ä–º–æ–∑: —Ç—è–Ω–µ—à—å, –∫–æ–≥–¥–∞ –±—É–∫—Å—É–µ—à—å.

–ì–ª–∞–≤–Ω–æ–µ ‚Äî **–Ω–µ –±–æ—è—Ç—å—Å—è –Ω–∞—á–∞—Ç—å** –∏ **–∏–¥—Ç–∏ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ**:

1. –ü–æ–Ω—è–ª –∑–∞–¥–∞—á—É
2. –†–µ—à–∏–ª –∫–∞–∫ —É–º–µ–µ—à—å
3. –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–ª –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏

> ¬´–ò–¥–µ–∞–ª—å–Ω—ã–π –∫–æ–¥ ‚Äî —Ç–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç. –ê –ø–æ—Ç–æ–º —É–∂–µ —á–∏—Ç–∞–µ—Ç—Å—è –∏ —É—Å–∫–æ—Ä—è–µ—Ç—Å—è.¬ª

