# Longest Subarray of 1's After Deleting One Element

Level: Medium

[–°—Å—ã–ª–∫–∞ –Ω–∞ –∑–∞–¥–∞—á—É](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

## üß† –ó–∞–¥–∞—á–∞:

> –î–∞–Ω –±–∏–Ω–∞—Ä–Ω—ã–π –º–∞—Å—Å–∏–≤ `nums`. –ù—É–∂–Ω–æ **—É–¥–∞–ª–∏—Ç—å –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç** (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ).  
> –í–µ—Ä–Ω—É—Ç—å –¥–ª–∏–Ω—É —Å–∞–º–æ–π –¥–ª–∏–Ω–Ω–æ–π –Ω–µ–ø—É—Å—Ç–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–µ–π **—Ç–æ–ª—å–∫–æ –µ–¥–∏–Ω–∏—Ü—ã**, –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.  
> –ï—Å–ª–∏ —Ç–∞–∫–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç ‚Äî –≤–µ—Ä–Ω—É—Ç—å `0`.

---

## üìå –ò–¥–µ—è:

- –ò—Å–ø–æ–ª—å–∑—É–µ–º **–¥–≤—É—Ö—É–∫–∞–∑–∞—Ç–µ–ª—å–Ω—É—é —Ç–µ—Ö–Ω–∏–∫—É** (—Å–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ)
- –î–æ–ø—É—Å–∫–∞–µ–º **–Ω–µ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ –Ω—É–ª—è** –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ
- –†–∞–∑–º–µ—Ä –æ–∫–Ω–∞ `right - left`, –Ω–æ **—É—á–∏—Ç—ã–≤–∞–µ–º, —á—Ç–æ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–¥–∞–ª—ë–Ω**

---

## üìè –°—Ç—Ä—É–∫—Ç—É—Ä–∞:

- `left, right int` ‚Äî –≥—Ä–∞–Ω–∏—Ü—ã –æ–∫–Ω–∞
- `zeroCount int` ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω—É–ª–µ–π –≤ —Ç–µ–∫—É—â–µ–º –æ–∫–Ω–µ
- `maxLen int` ‚Äî —Ä–µ–∑—É–ª—å—Ç–∞—Ç

---

## üîÅ –®–∞–≥–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞:

1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º `left = 0`, `zeroCount = 0`, `maxLen = 0`
2. –ü—Ä–æ—Ö–æ–¥–∏–º `right` –æ—Ç 0 –¥–æ –∫–æ–Ω—Ü–∞:
   - –ï—Å–ª–∏ `nums[right] == 0`, —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º `zeroCount`
   - –ï—Å–ª–∏ `zeroCount > 1` ‚Äî —Å–¥–≤–∏–≥–∞–µ–º `left` –∏ —É–º–µ–Ω—å—à–∞–µ–º `zeroCount`, –µ—Å–ª–∏ —Å–ª–µ–≤–∞ –±—ã–ª 0
3. –û–±–Ω–æ–≤–ª—è–µ–º `maxLen = max(maxLen, right - left)`
4. –í–æ–∑–≤—Ä–∞—â–∞–µ–º `maxLen`

---

## ‚è±Ô∏è –°–ª–æ–∂–Ω–æ—Å—Ç—å:

- –í—Ä–µ–º—è: O(n)
- –ü–∞–º—è—Ç—å: O(1)

---

## üìÑ –ü—Ä–∏–º–µ—Ä:

–í—Ö–æ–¥:
```go
nums := []int{1, 1, 0, 1}
```

–í—ã—Ö–æ–¥:
```go
3 // —É–¥–∞–ª—è–µ–º 0, –ø–æ–ª—É—á–∞–µ–º [1,1,1]
```

---

## üìù –†–µ—à–µ–Ω–∏–µ:

```go
func longestSubarray(nums []int) int {
	left := 0
	zeroCount := 0
	maxLen := 0

	for right := 0; right < len(nums); right++ {
		if nums[right] == 0 {
			zeroCount++
		}

		for zeroCount > 1 {
			if nums[left] == 0 {
				zeroCount--
			}
			left++
		}

		maxLen = max(maxLen, right-left)
	}

	return maxLen
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```

---

## üè∑ –¢–µ–≥–∏:
- Array
- Dynamic Programming
- Sliding Window

---
