# Unique Paths

Level: Medium

[Ссылка на задачу](https://leetcode.com/problems/unique-paths/)

## 🧠 Задача:

> Робот находится в левом верхнем углу сетки размером `m x n`.  
> Он может двигаться **только вправо или вниз**.  
> Найти количество уникальных путей до правого нижнего угла сетки.

> Гарантируется, что ответ ≤ 2 * 10⁹.

---

## 📌 Идея:

- Задача сводится к комбинаторике:  
  Чтобы дойти до (m-1, n-1), нужно сделать `(m-1)` шагов вниз и `(n-1)` шагов вправо, в любом порядке.
- Всего шагов: `(m + n - 2)`, из них `(m - 1)` вниз → формула сочетаний:  
  **C(m+n-2, m-1)**

---

## 📏 Структура:

- Функция `comb(n, k int) int` — считает сочетание C(n, k)
- Основная функция `uniquePaths(m, n int) int`

---

## 🔁 Шаги алгоритма:

1. Преобразуем задачу к C(m+n-2, m-1)
2. Оптимизируем вычисление сочетаний:
   - Используем формулу:  
     `res = res * (n - i + 1) / i`  
     чтобы избежать переполнения и лишнего факториала
3. Вернуть результат

---

## ⏱️ Сложность:

- Время: O(min(m, n))
- Память: O(1)

---

## 📄 Пример:

Вход:
```go
m := 3
n := 7
```

Выход:
```go
28
```

---

## 📝 Решение:

```go
func uniquePaths(m int, n int) int {
	return comb(m+n-2, m-1)
}

func comb(n, k int) int {
	if k > n-k {
		k = n - k
	}

	res := 1
	for i := 1; i <= k; i++ {
		res = res * (n - i + 1) / i
	}
	return res
}
```
