# Maximum Subsequence Score

Level: Medium

[–°—Å—ã–ª–∫–∞ –Ω–∞ –∑–∞–¥–∞—á—É](https://leetcode.com/problems/maximum-subsequence-score/)

## üß† –ó–∞–¥–∞—á–∞:

> –î–∞–Ω—ã –¥–≤–∞ –º–∞—Å—Å–∏–≤–∞ `nums1` –∏ `nums2` –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω—ã `n`, –∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ `k`.
> –ù—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å **–ø–æ–¥–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª–∏–Ω—ã `k`** –∏ –≤—ã—á–∏—Å–ª–∏—Ç—å –µ—ë **–æ—Ü–µ–Ω–∫—É (score)** –∫–∞–∫:
> `score = (—Å—É–º–º–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö nums1[i]) * (–º–∏–Ω–∏–º—É–º –∏–∑ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö nums2[i])`
> –í–µ—Ä–Ω—É—Ç—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤–æ–∑–º–æ–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ `score`.

---

## üìå –ò–¥–µ—è:

* –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∞—Ä—ã `(nums2[i], nums1[i])` **–ø–æ —É–±—ã–≤–∞–Ω–∏—é nums2\[i]**
* –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –Ω–∏–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—è —Å—É–º–º—É `k` –Ω–∞–∏–±–æ–ª—å—à–∏—Ö `nums1[i]` –≤ **min-heap**
* –î–ª—è –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏:

  * `nums2[i]` –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ ‚Äî **—Ç–µ–∫—É—â–µ–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ** —Å—Ä–µ–¥–∏ `k`
  * –°—á–∏—Ç–∞–µ–º `score = sum * nums2[i]`, –æ–±–Ω–æ–≤–ª—è–µ–º –º–∞–∫—Å–∏–º—É–º

---

## üìè –°—Ç—Ä—É–∫—Ç—É—Ä–∞:

* `pairs [][2]int` ‚Äî –ø–∞—Ä—ã `(nums2[i], nums1[i])`, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ `nums2`
* `heap MinHeap` ‚Äî –∫—É—á–∞ —Ä–∞–∑–º–µ—Ä–∞ `k` –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–∞–∏–º–µ–Ω—å—à–∏—Ö `nums1[i]`
* `sum int64` ‚Äî —Ç–µ–∫—É—â–∞—è —Å—É–º–º–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –∫—É—á–µ
* `result int64` ‚Äî —Ç–µ–∫—É—â–∏–π –º–∞–∫—Å–∏–º—É–º `score`

---

## üîÅ –®–∞–≥–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–∞:

1. –û–±—ä–µ–¥–∏–Ω–∏—Ç—å `nums1` –∏ `nums2` –≤ –ø–∞—Ä—ã `(nums2[i], nums1[i])`
2. –û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ —É–±—ã–≤–∞–Ω–∏—é `nums2[i]`
3. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å min-heap –∏ —Å—É–º–º—É
4. –î–ª—è –∫–∞–∂–¥–æ–π –ø–∞—Ä—ã:

   * –î–æ–±–∞–≤–∏—Ç—å `nums1[i]` –≤ –∫—É—á—É –∏ —Å—É–º–º—É
   * –ï—Å–ª–∏ –∫—É—á–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç `k` ‚Äî —É–¥–∞–ª–∏—Ç—å –º–∏–Ω–∏–º—É–º –∏ –æ–±–Ω–æ–≤–∏—Ç—å —Å—É–º–º—É
   * –ï—Å–ª–∏ –¥–ª–∏–Ω–∞ –∫—É—á–∏ —Ä–∞–≤–Ω–∞ `k`, –≤—ã—á–∏—Å–ª–∏—Ç—å `score = sum * nums2[i]`, –æ–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
5. –í–µ—Ä–Ω—É—Ç—å `result`

---

## ‚è±Ô∏è –°–ª–æ–∂–Ω–æ—Å—Ç—å:

* –í—Ä–µ–º—è: O(n log k)
* –ü–∞–º—è—Ç—å: O(k)

---

## üìÑ –ü—Ä–∏–º–µ—Ä:

–í—Ö–æ–¥:

```go
nums1 := []int{1,3,3,2}
nums2 := []int{2,1,3,4}
k := 3
```

–í—ã—Ö–æ–¥:

```go
12
```

–ü–æ—è—Å–Ω–µ–Ω–∏–µ: –≤—ã–±–∏—Ä–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã 0, 2, 3 ‚Üí —Å—É–º–º–∞ = 1+3+2 = 6, –º–∏–Ω–∏–º—É–º –∏–∑ nums2 = 2 ‚Üí 6\*2 = 12

---

## üìù –†–µ—à–µ–Ω–∏–µ:

```go
import (
	"container/heap"
	"sort"
)

type MinHeap []int

func (h MinHeap) Len() int           { return len(h) }
func (h MinHeap) Less(i, j int) bool { return h[i] < h[j] }
func (h MinHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *MinHeap) Push(x any)        { *h = append(*h, x.(int)) }
func (h *MinHeap) Pop() any {
	old := *h
	x := old[len(old)-1]
	*h = old[:len(old)-1]
	return x
}

func maxScore(nums1 []int, nums2 []int, k int) int64 {
	n := len(nums1)
	pairs := make([][2]int, n)
	for i := 0; i < n; i++ {
		pairs[i] = [2]int{nums2[i], nums1[i]}
	}

	sort.Slice(pairs, func(i, j int) bool {
		return pairs[i][0] > pairs[j][0]
	})

	h := &MinHeap{}
	heap.Init(h)
	var sum int64 = 0
	var result int64 = 0

	for _, p := range pairs {
		heap.Push(h, p[1])
		sum += int64(p[1])

		if h.Len() > k {
			removed := heap.Pop(h).(int)
			sum -= int64(removed)
		}

		if h.Len() == k {
			score := sum * int64(p[0])
			if score > result {
				result = score
			}
		}
	}

	return result
}
```

---

## üè∑ –¢–µ–≥–∏:
- Array
- Greedy
- Sorting
- Heap (Priority Queue)

---
